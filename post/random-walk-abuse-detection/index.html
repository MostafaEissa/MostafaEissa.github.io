<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta content name=keywords><meta content="Mostafa Abdelrahman" name=author><meta property="og:title" content="Random Walk based Fake Accounts Detection - Beyond Lambda"><meta property="og:url" content="https://mostafaeissa.github.io/post/random-walk-abuse-detection/"><meta property="og:description" content><meta property="og:type" content="website"><title>Random Walk based Fake Accounts Detection | Beyond Lambda</title>
<link rel=stylesheet href=https://mostafaeissa.github.io//css/style.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/styles/default.min.css><script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></head><body><section class=section><div class=container><nav class=nav><img src=/android-chrome-512x512.png alt=Avatar style=margin-right:1em height=100px><div class=nav-left style=flex-basis:auto><a class=nav-item href=https://mostafaeissa.github.io/><h1 class="title is-4">Beyond Lambda</h1></a><nav class="nav-item level is-mobile"><a class=level-item href=/tags>tags
</a><a class=level-item href=https://mostafaeissa.github.io/about/>about</a></nav></div><div class=nav-right><nav class="nav-item level is-mobile"><a class=level-item href=https://github.com/MostafaEissa target=_blank><span class=icon><i class="fa fa-github"></i>
</span></a><a class=level-item href=https://linkedin.com/in/mostafa-abdelrahman-16356b12a target=_blank><span class=icon><i class="fa fa-linkedin-square"></i>
</span></a><a class=level-item href=https://mostafaeissa.github.io/index.xml target=_blank><span class=icon><i class="fa fa-rss"></i></span></a></nav></div></nav></div></section><section class=section><div class=container><h1 class=title>Random Walk based Fake Accounts Detection</h1><h2 class="subtitle is-5">September 14, 2024 by Mostafa Abdelrahman</h2><div class=tags><a class="button is-link" href=https://mostafaeissa.github.io/tags/machine-learning>Machine Learning</a></div><div class=content><p>Attackers maintains fake accounts to use them for various reasons, for example, in a social media website, attackers could use them to post content to push a certain ideas. Another example in online retail where attackers use fake accounts to add fake reviews to improve the visibility of certain product.</p><p>In this post we will cover random walk based model proposed in <a href=https://people.duke.edu/~zg70/papers/sybilwalk.pdf>Random Walk based Fake Account Detection in Online Social Networks</a> to detect fake accounts.</p><p>The paper proposes a random-walk based method to detect fake accounts. The first step is to build a graph $G= (V,E)$ where a node $v$ represents a user and an edge $(u,v)$ indicates an interaction or a relationship between $u$ and $v$. For instance, the the online reviews setup an edge could mean $u$ and $v$ both reviewed the same product. The weights on the edge could depend on the strength of the relation/interaction (generally application dependent).</p><p>Detecting fake accounts or abusers is equivalent to assigning each user one of the labels <strong>benign</strong> or <strong>sybil</strong>. Where a benign label is for normal users and a sybil label is for abusers. In any system some users are verified (they can be trusted) while other others are known abusers (e.g., blocked by moderators). Hence, some users are already labeled and in order to label the remaining users we need to:</p><ol><li>Add two additional nodes to the graph; one for the <strong>benign</strong> label and the other for the <strong>sybil</strong> label.</li><li>Add an edge between each labeled user and the corresponding label</li></ol><p>The process is depicted in the example below:</p><p><img src=/images/random-walk-abuse-detection/example.png alt="label propagation example"></p><p>Then, we want to generate a <strong>badness score</strong> that represents how likely a node is a <strong>sybil</strong>. Intuitively, the closer a node is to the <strong>sybil</strong> label, the higher its badness score should be.</p><p>Each node $u$ has a set of neighbors denoted as $T_u$, each node is connected by an edge with weight $w_{uv}$. We define the weighed degree of node $u$ as $d_u = \sum_{v\in T_u}w_{uv}$. The badness score of a node $u$ is defined as:</p><p>$$
p_u = \sum_{v \in T_u} \frac{w_{uv}}{d_u} p_v
$$</p><p>i.e., the badness score of a node $u$ is a weighted sum of the badness score of its neighbors. Because the badness score of the nodes in $T_u$ also depends on their neighbors we need an iterative algorithm such that at the $t$th iteration the badness score is:</p><p>$$
p_u(t) = \sum_{v \in T_u} \frac{w_{uv}}{d_u} p_v(t-1)
$$</p><p>The algorithm keeps iterating until the change in the badness score between two iterations does not change. The algorithm is summarize below:</p><blockquote><p><strong>Input</strong>: Graph G = (V,E)</p><p><strong>Output</strong>: badness score for every user node u.</p><p><strong>Initialize</strong>:</p><p>$\hspace{2em}$ $p_u(0) = 0.5$ for every user node u.</p><p>$\hspace{2em}$ $p_{\text{benign}}(0) = 0$</p><p>$\hspace{2em}$ $p_{\text{sybil}(0)} = 1$</p><p>$\hspace{2em}$ $i = 1$</p><p>while $p_u(t) - p_u(t-1) > \epsilon$ and $ i &lt; \text{Iters}$:</p><p>$\hspace{2em}$for each user u do:</p><p>$\hspace{4em} p_u(t) = \sum_{v\in T_{u}}\frac{w_{uv}}{d_{u}}p_v(t-1)$</p><p>$\hspace{2em}$ $i = i + 1$</p></blockquote><p>This is very similar <a href=page-rank.md>PageRank Random Surfer Model</a> and be implemented in a few lines of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power_iter</span>(adjacency_matrix, max_iter, tol<span style=color:#f92672>=</span><span style=color:#ae81ff>1e-6</span>):
</span></span><span style=display:flex><span>        M <span style=color:#f92672>=</span> adjacency_matrix
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> adjacency_matrix<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#75715e># we initialize all nodes with badness score of 0.5</span>
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>ones((n))
</span></span><span style=display:flex><span>        x[BENIGN] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># benign node has a score of 0</span>
</span></span><span style=display:flex><span>        x[SYBIL] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># sybil node has a score of 1</span>
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;=</span> max_iter:
</span></span><span style=display:flex><span>            x_last <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> M<span style=color:#f92672>*</span>x
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>            <span style=color:#75715e># check convergence, l1 norm</span>
</span></span><span style=display:flex><span>            err <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>absolute(x <span style=color:#f92672>-</span> x_last)<span style=color:#f92672>.</span>sum()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> err <span style=color:#f92672>&lt;</span> n<span style=color:#f92672>*</span>tol:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            i<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x
</span></span></code></pre></div><p>The random walk based model presents a compelling and simple approach to detecting fake accounts in online settings by building the interaction graph we were able to trace the patterns and interactions associated with fraudulent behavior. Moreover, it can leverage both positive (sybil) and negative (benign) samples in the detection process making it more robust.</p></div></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script></body>