<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta content name=keywords><meta content="Mostafa Abdelrahman" name=author><meta property="og:title" content="Galloping Search - Beyond Lambda"><meta property="og:url" content="https://mostafaeissa.github.io/post/galloping-search/"><meta property="og:description" content><meta property="og:type" content="website"><title>Galloping Search | Beyond Lambda</title>
<link rel=stylesheet href=https://mostafaeissa.github.io//css/style.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/styles/default.min.css><script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></head><body><section class=section><div class=container><nav class=nav><img src=/android-chrome-512x512.png alt=Avatar style=margin-right:1em height=100px><div class=nav-left style=flex-basis:auto><a class=nav-item href=https://mostafaeissa.github.io/><h1 class="title is-4">Beyond Lambda</h1></a><nav class="nav-item level is-mobile"><a class=level-item href=/tags>tags
</a><a class=level-item href=https://mostafaeissa.github.io/about/>about</a></nav></div><div class=nav-right><nav class="nav-item level is-mobile"><a class=level-item href=https://github.com/MostafaEissa target=_blank><span class=icon><i class="fa fa-github"></i>
</span></a><a class=level-item href=https://linkedin.com/in/mostafa-abdelrahman-16356b12a target=_blank><span class=icon><i class="fa fa-linkedin-square"></i>
</span></a><a class=level-item href=https://mostafaeissa.github.io/index.xml target=_blank><span class=icon><i class="fa fa-rss"></i></span></a></nav></div></nav></div></section><section class=section><div class=container><h1 class=title>Galloping Search</h1><h2 class="subtitle is-5">July 26, 2024 by Mostafa Abdelrahman</h2><div class=tags><a class="button is-link" href=https://mostafaeissa.github.io/tags/algorithms>Algorithms</a></div><div class=content><p>Suppose we we have <strong>sorted</strong> array and we are interested in finding a particular element. There are a number of ways we can go about it.</p><p>Let&rsquo;s give a concrete example, The array is of length $\mathcal{L}$ containing the following elements:</p><pre tabindex=0><code>[
283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,
811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941
]
</code></pre><p>and we are interested in finding <code>467</code> (which resides at index 31). In our diagrams we will follow the same notation used in <a href=https://www.amazon.com/Information-Retrieval-Implementing-Evaluating-Engines/dp/0262528878>Information Retrieval Implementing and Evaluating Search Engines</a> excellent book.</p><h3 id=linear-search>Linear Search</h3><p>The simplest solution is to scan the array in a linear fashion until we find it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>linear_search</span>[A](arr: List[A], x: A) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> len(arr) <span style=color:#f92672>and</span> arr[i] <span style=color:#f92672>&lt;=</span> x:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> arr[i] <span style=color:#f92672>==</span> x:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> i
</span></span><span style=display:flex><span>		i <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#75715e># if we reach here then the element is not present</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Since the array is already sorted if we reach an element bigger than our target we can conclude that the target is not found in the array and we can terminate.</p><p>The diagram below shows how the linear search would go, at each step we <strong>hop</strong> one step until we find our target.</p><p><img src=/images/galloping-search/linear-search.png alt="Linear Search"></p><p>In the worst case we would need to scan the entire array which makes our time complexity $O(\mathcal{L})$</p><h3 id=binary-search>Binary Search</h3><p>A faster approach is binary search where we try to successively half the interval to scan until we find the target element. At each step we compare the target value with the middle element. If they are not equal and because the array is sorted we can eliminate half the array and search in the remaining half.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search</span>[A](arr: List[A], x: A, start:int<span style=color:#f92672>|</span><span style=color:#66d9ef>None</span><span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, end:int<span style=color:#f92672>|</span><span style=color:#66d9ef>None</span><span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> start <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>		start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> end <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>		end <span style=color:#f92672>=</span> len(arr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> end <span style=color:#f92672>&gt;=</span> start:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> start) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>        <span style=color:#75715e># If the element is present at the middle</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arr[mid] <span style=color:#f92672>==</span> x:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> mid
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>        <span style=color:#75715e># If the element is smaller than mid, then it can only be present in the left sub-array</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arr[mid] <span style=color:#f92672>&gt;</span> x:
</span></span><span style=display:flex><span>			end <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>        <span style=color:#75715e># Else it can only be present in the right sub-array</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			start <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> binary_search(arr, x, start, end)
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>    <span style=color:#75715e># if we reach here then the element is not present</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>The diagram below shows how the binary search would go, at each step we <strong>hop</strong> by half the length of the sub-array until we find our target.</p><p><img src=/images/galloping-search/binary-search.png alt="Binary Search"></p><p>Because we are halving the array at each step, binary search runs in logarithmic time with complexity $O(\log(\mathcal{L}))$</p><h3 id=galloping-search-combining-them-together>Galloping Search: Combining Them Together</h3><p>Galloping Search (a.k.a. exponential search) is an idea that tries to combine both approaches:</p><ul><li>First, we do a linear scan in <strong>exponentially increasing steps (gallops)</strong> until we hit an element larger than our target value.</li><li>Then, we do a binary search in the range between the last two jumps which is a smaller range than doing a binary search on the entire array.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>galloping_search</span>(arr: List[A], x: A) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>	n <span style=color:#f92672>=</span> len(arr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># if x is present at first location</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> arr[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> x:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>    <span style=color:#75715e># Find range for binary search by repeated doubling</span>
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>and</span> arr[i] <span style=color:#f92672>&lt;=</span> x:
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> binary_search( arr, i <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>, min(i, n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), x)
</span></span></code></pre></div><p>The diagram below shows how the galloping search would go. First, we <strong>hop</strong> in exponentially increasing steps {1,2,4,8,16,&mldr;} until we pass our target element. Then we do binary search between the previous and current position.</p><p><img src=/images/galloping-search/galloping-search.png alt="Galloping Search"></p><p>Galloping search also runs in logarithmic time but with complexity $O(\log(\mathcal{l}))$ where $\mathcal{l}$ is the index of the target element.</p><p>Galloping search can be faster if the target element is near the beginning of the array. This can be useful if we want to perform repeated searches i.e., find all elements in one array in another array.</p></div></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script></body>