<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta content name=keywords><meta content="Mostafa Abdelrahman" name=author><meta property="og:title" content="Buy It Again Recommendation - Beyond Lambda"><meta property="og:url" content="https://mostafaeissa.github.io/post/buy-it-again/"><meta property="og:description" content><meta property="og:type" content="website"><title>Buy It Again Recommendation | Beyond Lambda</title>
<link rel=stylesheet href=https://mostafaeissa.github.io//css/style.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/styles/default.min.css><script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></head><body><section class=section><div class=container><nav class=nav><img src=/android-chrome-512x512.png alt=Avatar style=margin-right:1em height=100px><div class=nav-left style=flex-basis:auto><a class=nav-item href=https://mostafaeissa.github.io/><h1 class="title is-4">Beyond Lambda</h1></a><nav class="nav-item level is-mobile"><a class=level-item href=/tags>tags
</a><a class=level-item href=https://mostafaeissa.github.io/about/>about</a></nav></div><div class=nav-right><nav class="nav-item level is-mobile"><a class=level-item href=https://github.com/MostafaEissa target=_blank><span class=icon><i class="fa fa-github"></i>
</span></a><a class=level-item href=https://linkedin.com/in/mostafa-abdelrahman-16356b12a target=_blank><span class=icon><i class="fa fa-linkedin-square"></i>
</span></a><a class=level-item href=https://mostafaeissa.github.io/index.xml target=_blank><span class=icon><i class="fa fa-rss"></i></span></a></nav></div></nav></div></section><section class=section><div class=container><h1 class=title>Buy It Again Recommendation</h1><h2 class="subtitle is-5">August 31, 2024 by Mostafa Abdelrahman</h2><div class=tags><a class="button is-link" href=https://mostafaeissa.github.io/tags/machine-learning>Machine Learning</a></div><div class=content><p>Buy-it-again is a popular recommendation model in online retail. In this post we will cover a simple model proposed in <a href=https://dl.acm.org/doi/pdf/10.1145/3219819.3219891>Buy it again: Modeling repeat purchase recommendations</a> that achieves good results despite its simplicity.</p><h1 id=customer-behavior>Customer Behavior</h1><p>In online retail, a customer basket consists of :</p><ul><li><strong>repeat items</strong>: items that the customer has consumed before, in previous baskets</li><li><strong>explore items</strong>: items that are new to the customer</li></ul><p>The ratio of repeat to explore items will differ from customer to customer and also from business to business. For instance, an online grocery store is likely to have a high repeat ratio while an online fashion store will have a higher explore ratio. In this post we will focus on the problem of recommending repeat items (a.k.a buy it again). Our input is the historical customer transactions consisting of previous bought products (an example is shown below).</p><table><thead><tr><th style=text-align:left>TRANSACTION_DT</th><th style=text-align:left>CUSTOMER_ID</th><th style=text-align:left>PRODUCT_ID</th></tr></thead><tbody><tr><td style=text-align:left>01-Aug-2024</td><td style=text-align:left>110405</td><td style=text-align:left>10372</td></tr><tr><td style=text-align:left>01-Aug-2024</td><td style=text-align:left>418983</td><td style=text-align:left>52535</td></tr><tr><td style=text-align:left>02-Aug-2024</td><td style=text-align:left>107331</td><td style=text-align:left>54103</td></tr><tr><td style=text-align:left>02-Aug-2024</td><td style=text-align:left>110405</td><td style=text-align:left>92129</td></tr><tr><td style=text-align:left>03-Aug-2024</td><td style=text-align:left>181995</td><td style=text-align:left>21445</td></tr><tr><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td><td style=text-align:left>&mldr;</td></tr></tbody></table><p>Before we explore various possible solutions, let&rsquo;s define the <strong>buy it again</strong> recommendation problem.</p><h1 id=problem-formulation>Problem Formulation</h1><p>We would like to find the probability that a customer $c_i$ who purchased product $p_i$ k times in the past will purchase it again at time $t$. We will assume that the purchase probability of different products are independent of each other. Then, we are are interested in calculating:</p><p>$$
P_{c_i, p_i}(t_{k+1}=t | t_1,t_2,&mldr;,t_k)
$$</p><p>This probability density can be composed into two parts:</p><ul><li>$Q_{c_i,p_i}(A_i= k+1)$: is the probability that a customer purchases the product another time given that they already purchased it k times</li><li>$R_{c_i, p_i}(t = t_{k+1} | t_1,t_2,&mldr;,t_k)$: is the probability that the customer makes a purchase at time $t_{k+1}$, conditioned on their repeat purchase history $t_1, t_2, &mldr;, t_k$ of that product.</li></ul><p>Then, our probability of interest can be approximated as:</p><p>$$
\begin{aligned}
P_{c_i, p_i}(t_{k+1}=t | t_1,t_2,&mldr;,t_k) \approx Q_{c_i,p_i}(A_i) \times R_{c_i, p_i}(t | t_1,t_2,&mldr;,t_k) \hspace{5em} (1)
\end{aligned}
$$</p><h1 id=baseline-p-topfreq>Baseline: P-TopFreq</h1><p>A simple and intuitive approach is using the customer purchase history. <strong>P-TopFreq</strong> finds the most frequent k items in the users&rsquo; purchase history and use them for recommendation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># count how many times each product was bought per customer</span>
</span></span><span style=display:flex><span>num_bought_products_per_customer_df <span style=color:#f92672>=</span> purchase_history_df
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>, <span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>agg(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TRANSACTION_DT&#34;</span>)<span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># sort products in descending order according to the number they were bought</span>
</span></span><span style=display:flex><span>num_bought_products_per_customer_df <span style=color:#f92672>=</span> num_bought_products_per_customer_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>sort([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>,<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>], descending<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># return the top K items per customer as the next recommendation</span>
</span></span><span style=display:flex><span>topk_bought_products_per_customer_df <span style=color:#f92672>=</span> num_bought_products_per_customer_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>head(topk)
</span></span></code></pre></div><p>According to <a href=https://dl.acm.org/doi/pdf/10.1145/3587153>A next basket recommendation reality check</a> , many state-of-the-art deep learning based models show modest or even no improvements compared to this simple frequency-based baseline.</p><h1 id=rca-repeat-customer-probability-model>RCA: Repeat Customer Probability Model</h1><p>Our first model will completely ignore the time component and assume that $R_{c_i, p_i}(t)$ is a fixed constant across all customers and products. Furthermore, the model will assume that $Q_{c_i,p_i}(A_i)$ is fixed across all customers (i.e., $Q_{c_i,p_i}(A_i) \approx Q_{p_i}(A_i)$ ). Then, for each product $p_i$ ,we approximate its $Q_{p_i}(A_i)$ by the repeat customer probability ($RCP_{p_i}$):</p><p>$$
RCP_{p_i} = \frac{\text{# customers who bought product} \hspace{.2em} p_i \hspace{.2em} \text{more than once}}{\text{# customers who bought the product} \hspace{.2em} p_i \hspace{.2em} \text{at least once}}
$$</p><p>We generate recommendations by considering all the repeat purchasable products previously bought by customers and ranking them in the descending order of their RCA.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># count how many times each product was bought per customer</span>
</span></span><span style=display:flex><span>num_bought_products_per_customer_df <span style=color:#f92672>=</span> purchase_history_df
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>, <span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>agg(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TRANSACTION_DT&#34;</span>)<span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># sort products in descending order according to the number they were bought</span>
</span></span><span style=display:flex><span>num_bought_products_per_customer_df <span style=color:#f92672>=</span> num_bought_products_per_customer_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>sort([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>,<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>], descending<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># for each product calculate the RCA as the ratio between customers </span>
</span></span><span style=display:flex><span><span style=color:#75715e># who bought the prodct more than once to those who bought it at least once</span>
</span></span><span style=display:flex><span>products_RCA_df <span style=color:#f92672>=</span> num_bought_products_per_customer_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by(<span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>agg([
</span></span><span style=display:flex><span>            pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>)<span style=color:#f92672>.</span>count()\
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;NUM_CUSTOMERS_BOUGHT_PRODUCT_AT_LEAST_ONCE&#34;</span>), 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>)<span style=color:#f92672>.</span>filter(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>)\
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;NUM_CUSTOMERS_BOUGHT_PRODUCT_MORE_THAN_ONCE&#34;</span>)
</span></span><span style=display:flex><span>            ])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>with_columns(
</span></span><span style=display:flex><span>            RCA<span style=color:#f92672>=</span>pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;NUM_CUSTOMERS_BOUGHT_PRODUCT_MORE_THAN_ONCE&#34;</span>)<span style=color:#f92672>/</span>pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;NUM_CUSTOMERS_BOUGHT_PRODUCT_AT_LEAST_ONCE&#34;</span>)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># choose products with highest RCA in customer history</span>
</span></span><span style=display:flex><span>topk_rca_products_per_customer_df <span style=color:#f92672>=</span> purchase_history_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>join(products_RCA_df, on<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>, how<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;inner&#39;</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>sort([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>, <span style=color:#e6db74>&#34;RCA&#34;</span>], descending<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>head(topk)
</span></span></code></pre></div><p>This model is based on the idea that not all products are repeat purchasable (e.g., fashion vs groceries) and the repeat purchase rate varies among repeat purchasable products.</p><h1 id=atd-aggregate-time-distribution-model>ATD: Aggregate Time Distribution Model</h1><p>ATD is based on the idea that for each product we have multiple customers who purchased it, if we aggregate their behaviors we can determine the repeat purchase characteristic of that product. For each product, we want to determine the distribution of the repeat purchase time intervals.</p><p>In the paper, they used a log-normal distribution to model $R_{c_i, p_i}(t)$ and assumed it is the same for all customers for the same product. The distribution parameters $\bar{\mu_i}$ and $\bar{\sigma_i}^2$ are empirically estimated from the data.</p><p>$$
R_{p_i}(t) = \frac{1}{\sqrt{2\pi}t \bar{\sigma_i}} exp [ -\frac{(ln t - \bar{\mu_i})^2}{2\bar{\sigma_i}^2}] , t > 0
$$</p><p>We still use RCA calculated in the previous model to estimate $Q_{p_i}(A_i)$. In the paper, they proposed to filter all products with RCA above a certain threshold and then rank products based on their $R_{p_i}(t)$. However, in our implementation we will rank product based on the $Q_{p_i}(A_i) \times R_{p_i}(t)$ value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># calculate mean time to repurchase per product</span>
</span></span><span style=display:flex><span>products_mean_time_to_repurchase_df <span style=color:#f92672>=</span> purchase_history_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>sort([<span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>, <span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>, <span style=color:#e6db74>&#34;TRANSACTION_DT&#34;</span>], descending<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>, <span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>], maintain_order<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>agg(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TRANSACTION_DT&#34;</span>)<span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>), (pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TRANSACTION_DT&#34;</span>)<span style=color:#f92672>.</span>diff()<span style=color:#f92672>/</span>pl<span style=color:#f92672>.</span>duration(milliseconds<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>))<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;TIME_TO_NEXT_PURCHASE&#34;</span>))\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>filter(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;NUM_BOUGHT&#34;</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>agg(
</span></span><span style=display:flex><span>                pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TIME_TO_NEXT_PURCHASE&#34;</span>)<span style=color:#f92672>.</span>explode()<span style=color:#f92672>.</span>drop_nulls()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;MEAN_TIME_TO_NEXT_PURCHASE&#34;</span>), 
</span></span><span style=display:flex><span>                pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TIME_TO_NEXT_PURCHASE&#34;</span>)<span style=color:#f92672>.</span>explode()<span style=color:#f92672>.</span>drop_nulls()<span style=color:#f92672>.</span>log()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;LOG_MEAN_TIME_TO_NEXT_PURCHASE&#34;</span>)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># estimate distribution parameters</span>
</span></span><span style=display:flex><span>products_mean_time_to_repurchase_params_df <span style=color:#f92672>=</span> products_mean_time_to_repurchase_df
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>with_columns(
</span></span><span style=display:flex><span>                pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;LOG_MEAN_TIME_TO_NEXT_PURCHASE&#34;</span>)<span style=color:#f92672>.</span>map_elements(<span style=color:#66d9ef>lambda</span> x : x<span style=color:#f92672>.</span>mean())<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;mean&#34;</span>), 
</span></span><span style=display:flex><span>                pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;LOG_MEAN_TIME_TO_NEXT_PURCHASE&#34;</span>)<span style=color:#f92672>.</span>map_elements(<span style=color:#66d9ef>lambda</span> x : x<span style=color:#f92672>.</span>std())<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;std&#34;</span>)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># find when was each product last purchased</span>
</span></span><span style=display:flex><span>last_purchase_time_df <span style=color:#f92672>=</span> purchase_history_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>, <span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>agg(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;TRANSACTION_DT&#34;</span>)<span style=color:#f92672>.</span>max()<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;LAST_TRANSACTION_DT&#34;</span>))
</span></span></code></pre></div><p>Now, for any customer, if we want to recommend repeat products at a time $t_{new}$ in the future we can use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>products_mean_time_to_repurchase_params_df\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>join(products_RCA_df, on<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>], how<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;inner&#34;</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>join(last_purchase_time_df, on<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;PRODUCT_ID&#34;</span>], how<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;inner&#34;</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>with_columns(((T_NEW <span style=color:#f92672>-</span> pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;LAST_TRANSACTION_DT&#34;</span>))<span style=color:#f92672>/</span>pl<span style=color:#f92672>.</span>duration(milliseconds<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>))<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;TIME_TO_NEXT_PURCHASE&#34;</span>))\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>with_columns(pl<span style=color:#f92672>.</span>struct([<span style=color:#e6db74>&#34;RCA&#34;</span>, <span style=color:#e6db74>&#34;std&#34;</span>, <span style=color:#e6db74>&#34;mean&#34;</span>, <span style=color:#e6db74>&#34;TIME_TO_NEXT_PURCHASE&#34;</span>])<span style=color:#f92672>.</span>map_elements(
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#34;RCA&#34;</span>] <span style=color:#f92672>*</span> stats<span style=color:#f92672>.</span>lognorm<span style=color:#f92672>.</span>pdf(x[<span style=color:#e6db74>&#34;TIME_TO_NEXT_PURCHASE&#34;</span>], s<span style=color:#f92672>=</span>x[<span style=color:#e6db74>&#34;std&#34;</span>], scale<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>exp(x[<span style=color:#e6db74>&#34;mean&#34;</span>]))
</span></span><span style=display:flex><span>                ,return_dtype<span style=color:#f92672>=</span>pl<span style=color:#f92672>.</span>Float64)<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;score&#34;</span>)
</span></span><span style=display:flex><span>        )\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>filter(pl<span style=color:#f92672>.</span>col(<span style=color:#e6db74>&#34;score&#34;</span>)<span style=color:#f92672>.</span>is_not_nan())\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>sort([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>, <span style=color:#e6db74>&#34;score&#34;</span>], descending<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>group_by([<span style=color:#e6db74>&#34;CUSTOMER_ID&#34;</span>])\
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>head(topk)
</span></span></code></pre></div><p>This models improves upon the RCA model by incorporating the time to last purchase. Each product has a mean time to repurchase depending on its nature, for example, customers buy milk once a week but buy detergent once a months. ATD model accounts for this fact by adjusting the probability of repurchase to be highest as the time to last purchase is closest to the mean and drops if a new purchase has been recently made (customer has the product and unlikely to buy it again or a long time has passed since the last purchase (customer is no longer interested in that product).</p><h1 id=conclusion>Conclusion</h1><p>The paper demonstrates that the ATD model, despite its simplicity, delivers a significant boost in key metrics such as precision, recall, and NDCG. It also touches on more sophisticated models like the Modified Poisson-Gamma Model (MPG), which we might explore in a future post. I highly recommend diving into the paper for a deeper understanding.</p><p>As data scientists, our primary goal should be to address business challenges, not just to implement the latest complex models. Before delving into intricate solutions, it&rsquo;s essential to assess your business case, analyze your data, and test whether simpler models can effectively meet your objectives.</p><h1 id=references>References</h1><ul><li><p>Li, M., Jullien, S., Ariannezhad, M., & de Rijke, M. (2023). A next basket recommendation reality check. ACM Transactions on Information Systems, 41(4), 1-29. (<a href=https://dl.acm.org/doi/pdf/10.1145/3587153>pdf</a>)</p></li><li><p>Bhagat, R., Muralidharan, S., Lobzhanidze, A., & Vishwanath, S. (2018, July). Buy it again: Modeling repeat purchase recommendations. In Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery & data mining (pp. 62-70). (<a href=https://dl.acm.org/doi/pdf/10.1145/3219819.3219891>pdf</a>)</p></li></ul></div></div></section><section class=section><div class="container has-text-centered"><p></p></div></section><script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script></body>